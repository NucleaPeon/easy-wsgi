import imp, os, re, sys, config, importlib

'''
Class that contains two parts:
    - replacement of tags with tags + persistant data as specified in config file
    - regex replacement for <?wsgi ?> method calls in html for dynamic content
'''

class Html():
    structure = {}
    
    def __init(self):
        self.structure['html']  = config.TEMPLATES.get("html", None)
        self.structure['/html'] = config.TEMPLATES.get("/html", None)
        self.structure['head']  = config.TEMPLATES.get("head", None)
        self.structure['/head'] = config.TEMPLATES.get("/head", None)
        self.structure['body']  = config.TEMPLATES.get("body", None)
        self.structure['/body'] = config.TEMPLATES.get("/body", None)

    def __str__(self):
        return "{}\n{}\n{}\n{}\n{}\n{}\n".format(
            *structure.values())

    def parse(self, htmlfile=None):
        '''
        :Description:
            Replaces the incoming htmlfile's tags with those
            in the Template, or none at all.
            
            Tags that can be Templated are limited to html, body and head.
            If you want autogenerated code beyond that, Template wsgi tags.
            
            Templates are not recommended on pages where the main tags:
                - html
                - body
                - head
            are manipulated because we can either replace ALL instances of
            <tag> with the Template, or the first instance. Even if comments
            are stripped out that may contain the strings, jQuery may require
            <tag> references (or at least javascript), so this method is
            dangerous. The *correct* solution to using templates is to not
            use any input files whatsoever. In fact, if parse() detects
            a None input file, it will auto generate to the best of its ability,
            a functioning html file even if it ends up blank.
            
            Because Templates are created first, then wsgi tags are parsed,
            a template can reference a python method so absolutely NO
            html file is required for wsgi to run properly.
            Cool trick eh?
            
        :Parameters:
            - htmlfile: string; path to the file to read and replace
              tags with
              
        :Returns:
            - string; output of replaced input file with corrections made
        '''
        templatedhtml = []
        # Must append in order
        if not htmlfile is None:
            # we have a string to replace
            templatedhtml = open(htmlfile, 'r').read()
            for key in self.structure.keys():
                if not self.structure.get(key) is None:
                    templatedhtml.replace(key, 
                                          self.structure[key])
                
        else:
            for x in ['html', 'head', '/head', 'body', '/body', '/html']:
                if self.structure.get(x) is None:
                    templatedhtml.append('<{}>'.format(x))
                else:
                    templatedhtml.append(self.structure[x])
        return templatedhtml
    
class Wsgi():
    '''
    :Description:
        This class represents a tag. Once a tag object is found (initialized),
        this class allows retrieval of the module name (and loaded module object),
        Class (if applicable), method, and any/all arguments inside it.
        
        Wsgi tag format should read: <?wsgi mod class method ?>
        with optional additional arguments. If there is no class, it SHOULD
        be set to "None"
    '''
    
    def __init__(self, *args):
        '''
        '''
        self.args = args
        
        
    def replace(self, string):
        '''
        :Description:
            Based on the parameters given,
            return the results (not as a string, but natively)
        '''
        pass

def __replace_tag(html_contents, wsgi_string, wsgi_result):
    """
    :Description:
        Replaces the wsgi tag with the wsgi result.
        This method does not actually *call* the wsgi method, nor
        ensure that the module and class and arguments are parsed.
        It's a simple "go through html file and replace tags with
        result".
        
    :Parameters:
        - html_contents: string; entire html file
        - wsgi_string: the tag complete with module, class and args
        - wsgi_result: the returned value(s) of the method call
    """
    return re.sub(r'''<\?wsgi {} \?>'''.format(wsgi_string),
                     str(wsgi_result), html_contents)

def __call_wsgi(cmd_tuple):
    """
    :Description:
        Calls and returns the python command specified by wsgi, does NOT 
        convert it to a string format.
        Arguments for methods are ALWAYS in a string.
        
        DANGER:
            You may need to parse the string if you are expecting a list or tuple or 
            dictionary. You *may* have to use eval, but it is DANGEROUS!
        
    :Parameters:
        - cmd_tuple: tuple or list in format (module, (...), args,) where the 
          (...) refers to a tuple where one or more strings can be specified;
          a minimum of a method call must be specified (without ending ()'s )
          that is lead up by zero-or-more python components (such as classes).
        :example:
            (<module datetime>, ('datetime', 'now',)) -> current datetime
            
    :Returns:
        Result of python method call
    """
    # Check for "." in the module path: If found, this is a customized
    # module that we import using full absolute path; otherwise we
    # attempt a simple __import__ on that module, which works for official
    # imports and modules on the sys.path (customs won't be)
    
    mod = importlib.import_module(cmd_tuple[0])
#    if mod == None:
#        raise Exception("Error: WSGI Module Import invalid; Got 'NoneType'")
    
    # Arguments parsed here:
#    funcbuild = mod
    
#    for x in cmd_tuple[1]:
#        funcbuild = getattr(mod, x)

#    if cmd_tuple[2]:
#        # TODO: Parse to make arguments sane (strings don't pass properly)
#        arguments = cmd_tuple[2].split(" ")
#        proper_args = []
#        started = False
#        quoted_arg = ''
#        for arg in arguments:
#            if not arg:
#                continue
#            if arg[0] == '"':
#                started = True
#                quoted_arg = arg.strip('"')
#                if quoted_arg[len(quoted_arg) - 1] == '"':
#                    started = False
#                    proper_args.append(quoted_arg)
#                    continue
#            elif arg[len(arg) - 1] == '"':
#                quoted_arg += " " + arg.strip('"')
#                started = False
#                proper_args.append(quoted_arg)
#            else:
#                if not started:
#                    proper_args.append(arg)
#                else:
#                    quoted_arg += " " + arg
#        return funcbuild(*proper_args)
    return str(mod)
    

def parse_wsgi_tags(html_contents):
    """
    :Description:
        Find all wsgi tags found in the html body and for each instance,
        call a method to determine the python values of the method call,
        then replace the results of the method call with the tag for the
        html body.
        
        Each step is done in a different method. Actual replacement is done
        here.
        
    :Parameters:
        - html_contents: string of the entire html file
        
    :Returns:
        String of html contents with replaced wsgi tags and results.
    """
        
    m = re.findall('<\?wsgi(.*)\?>', html_contents)
    mod     = ''
    classes = ''
    args    = ''
    new_contents = ''
    for pystring in m:
        pystring = pystring.strip()
        if pystring:
            parsed = pystring.split(' ') # list [mod, method/class, args]
            mod = parsed[0]
            classes = parsed[1].split('.')
            try:
                # Place arguments in a string, not as a list
                args = ' '.join(parsed[2:])
            except:
                pass
            passin = [mod, classes, args]
            result = __call_wsgi(passin)
            html_contents = __replace_tag(html_contents, pystring, result)
            
    return html_contents
